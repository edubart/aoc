require 'io'
require 'vector'
require 'math'

-- vec3
local vec3 = @record{x: int32, y: int32, z: int32}

function vec3.__add(a: vec3, b: vec3): vec3
  return vec3{a.x+b.x, a.y+b.y, a.z+b.z}
end

-- Cuboid
local Cuboid = @record{
  i: vec3,
  e: vec3,
}

local function intersect_axis(aix: int64, aex: int64, bix: int64, bex: int64): (int64, int64)
  if bix >= aix and bix <= aex then
    return bix, math.min(bex, aex)
  elseif bex >= aix and bex <= aex then
    return math.max(bix, aix), bex
  elseif bix <= aix and bex >= aex then
    return aix, aex
  else
    return 0, -1
  end
end

function Cuboid.intersect(a: Cuboid, b: Cuboid): Cuboid
  local res: Cuboid
  res.i.x, res.e.x = intersect_axis(a.i.x, a.e.x, b.i.x, b.e.x)
  res.i.y, res.e.y = intersect_axis(a.i.y, a.e.y, b.i.y, b.e.y)
  res.i.z, res.e.z = intersect_axis(a.i.z, a.e.z, b.i.z, b.e.z)
  return res
end

function Cuboid.merge(a: Cuboid, b: Cuboid): Cuboid
  local res: Cuboid
  res.i.x, res.e.x = math.min(a.i.x, b.i.x), math.max(a.e.x, b.e.x)
  res.i.y, res.e.y = math.min(a.i.y, b.i.y), math.max(a.e.y, b.e.y)
  res.i.z, res.e.z = math.min(a.i.z, b.i.z), math.max(a.e.z, b.e.z)
  return res
end

function Cuboid.area(self: Cuboid)
  return (@int64)(self.e.x-self.i.x+1)*(@int64)(self.e.y-self.i.y+1)*(@int64)(self.e.z-self.i.z+1)
end

function Cuboid.valid(self: Cuboid)
  return self.e.x >= self.i.x and self.e.y >= self.i.y and self.e.z >= self.i.z
end

local BRANCH_SECTION: Cuboid <const> = Cuboid{i={0,0,0},e={-1,-1,-1}}

-- Octree
local OctreeNode = @record{
  section: Cuboid,
  nodes: [8]*OctreeNode,
}

function OctreeNode:destroy()
  for i,node in ipairs(self.nodes) do
    if node then
      node:destroy()
    end
  end
  delete(self)
end

function OctreeNode:isleaf()
  return self.section ~= BRANCH_SECTION
end

function OctreeNode:set(pos: vec3, size: int32, section: Cuboid)
  if self:isleaf() then
    local inter = self.section:intersect(section)
    if inter == section then
      return
    end
    if inter == self.section then
      self.section = section
      return
    end
    local merged = self.section:merge(section)
    if merged:area() == self.section:area() + section:area() - inter:area() then
      self.section = merged
      return
    end
  end
  local bounds = Cuboid{pos, vec3{pos.x+size-1,pos.y+size-1,pos.z+size-1}}
  if section == bounds then
    self.section = section
    for i,node in ipairs(self.nodes) do
      if node then
        node:destroy()
      end
    end
    self.nodes = {}
    return
  end
  local halfsize = size // 2
  if self:isleaf() then -- split nodes
    local i = 0
    for oz:int32=0,1 do
      for oy:int32=0,1 do
        for ox:int32=0,1 do
          local nodebounds: Cuboid = {
            i=pos+vec3{ox*halfsize,oy*halfsize,oz*halfsize},
            e=pos+vec3{(ox+1)*halfsize-1,(oy+1)*halfsize-1,(oz+1)*halfsize-1},
          }
          local nodesection = self.section:intersect(nodebounds)
          if nodesection:area() > 0 then
            self.nodes[i] = new(OctreeNode{section=nodesection})
          end
          i = i + 1
        end
      end
    end
    self.section = BRANCH_SECTION
  end
  do -- update nodes
    local i = 0
    for oz:int32=0,1 do
      for oy:int32=0,1 do
        for ox:int32=0,1 do
          local nodebounds: Cuboid = {
            i=pos+vec3{ox*halfsize,oy*halfsize,oz*halfsize},
            e=pos+vec3{(ox+1)*halfsize-1,(oy+1)*halfsize-1,(oz+1)*halfsize-1},
          }
          local nodesection = section:intersect(nodebounds)
          if nodesection:area() > 0 then
            local node = self.nodes[i]
            if not node then
              node = new(OctreeNode{section=nodesection})
              self.nodes[i] = node
            else
              node:set(nodebounds.i, halfsize, nodesection)
            end
          end
          i = i + 1
        end
      end
    end
  end
  do -- merge nodes
    local count = 0
    local i = 0
    for oz:int32=0,1 do
      for oy:int32=0,1 do
        for ox:int32=0,1 do
          local node = self.nodes[i]
          local nodebounds: Cuboid = {
            i=pos+vec3{ox*halfsize,oy*halfsize,oz*halfsize},
            e=pos+vec3{(ox+1)*halfsize-1,(oy+1)*halfsize-1,(oz+1)*halfsize-1},
          }
          if node and node:isleaf() and node.section == nodebounds then
            count = count + 1
          end
          i = i + 1
        end
      end
    end
    if count >= 8 then
      self.section = bounds
      for i,node in ipairs(self.nodes) do
        node:destroy()
      end
      self.nodes = {}
    end
  end
end

function OctreeNode:count()
  if self:isleaf() then
    return self.section:area()
  end
  local count = 0
  for i,leaf in ipairs(self.nodes) do
    if leaf then
      count = count + leaf:count()
    end
  end
  return count
end

local N <comptime> = 131072
local root = new(OctreeNode{section=BRANCH_SECTION})

local rules: vector(Cuboid)

local function add(newrule: Cuboid)
  for i=0,<#rules do
    local rule = rules[i]
    local inte = newrule:intersect(rule)
    local merged = newrule:merge(rule)
    if merged:area() == newrule:area() + rule:area() - inte:area() then
      rules[i] = merged
      return
    end
  end
  rules:push(newrule)
end

local function remove(remrule: Cuboid)
  local oldrules <close> = rules
  rules = {}
  for i,rule in ipairs(oldrules) do
    local inte = remrule:intersect(rule)
    if inte:area() == 0 then
      rules:push(rule)
    else
      local nrule: Cuboid
      for ix=1,3 do
        switch ix do
          case 1 then nrule.i.x = rule.i.x   nrule.e.x = inte.i.x-1
          case 2 then nrule.i.x = inte.i.x   nrule.e.x = inte.e.x
          case 3 then nrule.i.x = inte.e.x+1 nrule.e.x = rule.e.x
        end
        for iy=1,3 do
          switch iy do
            case 1 then nrule.i.y = rule.i.y   nrule.e.y = inte.i.y-1
            case 2 then nrule.i.y = inte.i.y   nrule.e.y = inte.e.y
            case 3 then nrule.i.y = inte.e.y+1 nrule.e.y = rule.e.y
          end
          for iz=1,3 do
            switch iz do
              case 1 then nrule.i.z = rule.i.z   nrule.e.z = inte.i.z-1
              case 2 then nrule.i.z = inte.i.z   nrule.e.z = inte.e.z
              case 3 then nrule.i.z = inte.e.z+1 nrule.e.z = rule.e.z
            end
            if nrule:valid() and nrule ~= inte then
              add(nrule)
            end
          end
        end
      end
    end
  end
end

local function read_input()
  for line <close> in io.lines('day22.txt') do
    local ok, caps <close> = line:matchview('(%a+) x=([-%d]+)%.%.([-%d]+),y=([-%d]+)%.%.([-%d]+),z=([-%d]+)%.%.([-%d]+)')
    local on: boolean = caps[1] == 'on'
    local pi: vec3 = {tointeger(caps[2]),tointeger(caps[4]),tointeger(caps[6])}
    local pe: vec3 = {tointeger(caps[3]),tointeger(caps[5]),tointeger(caps[7])}
    local rule = Cuboid{pi, pe}
    if rule:valid() then
      if on then
        add(rule)
      else
        remove(rule)
      end
    end
  end
end

local function part1()
  $root = OctreeNode{section=BRANCH_SECTION}
  for i,rule in ipairs(rules) do
    rule.i = vec3{math.max(rule.i.x,-50),math.max(rule.i.y,-50),math.max(rule.i.z,-50)}
    rule.e = vec3{math.min(rule.e.x, 50),math.min(rule.e.y, 50),math.min(rule.e.z, 50)}
    if rule:valid() then
      root:set({-N,-N,-N}, 2*N, rule)
    end
  end
  return root:count()
end

local function part2()
  $root = OctreeNode{section=BRANCH_SECTION}
  for i,rule in ipairs(rules) do
    root:set({-N,-N,-N}, 2*N, rule)
  end
  return root:count()
end

read_input()

local p1 = part1()
print('Part 1', p1)
assert(p1 == 564654)

local p2 = part2()
print('Part 2', root:count())
assert(p2 == 1214193181891104)
