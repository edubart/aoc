require 'io'
require 'hashmap'
require 'heapqueue'
require 'math'
require 'list'

local grid: [500][500]int8
local nodes: [500][500]int32

-- read tiles
local N = 0
local y = 0
for line in io.lines('day15.txt') do
  if N == 0 then N = #line end
  local x = 0
  for c in line:gmatch('%d') do
    grid[y][x] = tointeger(c)
    x = x + 1
  end
  y = y + 1
end

-- expand tiles
for y=0,<5*N do
  for x=0,<5*N do
    if x < N and y < N then continue end
    local risk = grid[y % N][x % N] + (x // N) + (y // N)
    grid[y][x] = risk <= 9 and risk or risk % 9
  end
end

local Point = @record{x: int16, y: int16}
local FrontierEntry = @record{pos: Point, cost: int32}
function FrontierEntry.__lt(a: FrontierEntry, b: FrontierEntry)
  return a.cost <= b.cost
end

-- A* algorithm, (see https://www.redblobgames.com/pathfinding/a-star/introduction.html)
local function astar(n: int16): int32
  local start = Point{0,0}
  local goal = Point{n-1, n-1}
  local frontier: heapqueue(FrontierEntry)
  nodes = {}
  frontier:reserve(1000)
  frontier:push{start, 0}
  while true do
    local current = frontier:pop()
    if current.pos == goal then break end -- reached goal
    for _,d in ipairs(&(@[]Point){{-1,0},{1,0},{0,-1},{0,1}}) do
      local y, x = current.pos.y+d.y, current.pos.x+d.x
      if y >= 0 and y < n and x >= 0 and x < n then
        local cost = current.cost + grid[y][x]
        local nodecost = nodes[y][x]
        if nodecost == 0 or cost < nodecost then
          frontier:push{Point{x,y}, cost}
          nodes[y][x] = cost
        end
      end
    end
  end
  return nodes[goal.y][goal.x]
end

print('Part 1', astar(N))
print('Part 2', astar(N*5))
